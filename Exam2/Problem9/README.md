## Perfect Squares

* The problem entails finding the least number of perfect squares which still sum up to the given n. Prefect squares are special number that are composed of same numbers. The difficulty of this problem lies where one must check that a possible number is a square and in addition it must check other possible combinations to sum up to the given n. Once again repeated work is occurred when trying to figure out the combination. To resolve this problem, an array will be constructed. Next, a number will be divided by two. In doing so we will discover the range of numbers that have the possibility to be a square. Next, loop to get possible squares and then comparing the value and storing the minimum in the array. Lastly when the iteration is concluded the dp array will hold the minimum value to the desired sum.

* This solution used the creation of the dp array to store the results. It displays a recursive property without actually employing recursion. First It is very important to slice the number in half to reduce the numbers being checked. This increases the speed and in addition it further reduces the amount of work done. Lastly in stores square combinations and returns the smallest sum to achieve the desired sum. It does this iteratively but since an array as well as a smaller range is employed it makes this solution dynamic.

* Using IDEAL this problem first identified the problem. The problem was finding valid numbers that were perfect squares, was a factor of the given number and that the possible combination would sum up to N using the smallest possible squares. The goal was to get a result that met all of these requirements. Possible solutions would be to use an edit distance type approach, but it would lead to evaluating numbers that wouldnâ€™t even be possible or meet the square criteria. Due to this numbers are checked, and the range of checked numbers is halved. After looking at this problem I can honestly say this problem is very difficult as well. Halving the possible iteration and checking for squares as imperative to the creation of an efficient solution. Using the dukes 7 steps this pattern was recognized. As before the problem was decomposed. If the desired result it attained add to it until the solution is met. For this problem, abstraction was essential because it allowed me to see that not all numbers were being evaluated and allowed for dynamic programming. Overall, the problem was decomposed successfully but I still believe finding the pattern in the hardest part. Once this step is completed any data structure can be manipulated to reflect the answer trying to be achieved. 
