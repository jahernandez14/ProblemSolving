## Arithmetic Slices

* The purpose of this problem is to find all possible arithmetic combinations of a given array. An arithmetic combination is one that is at least of length three and that all the numbers of the set are the same distance from each other. Example [1,3,4,7,9], this example would produce a result of 6. Like all dynamic problems here the problem is repeated work. The inefficient way to check all routes but by storing the possible routes and storing them. In this particular example the accumulated sum is stored in an array and then returns the sum of all possible arithmetic combinations for a certain element. This example uses recursive elements and returns the sum of the array. 

* In this problem the solution is stored in an array. In addition, it is assumed that the given array is sorted. It iterates through the array and find every combination for each element. It does this by comparing two elements and if they are equal to eachother then it is a valid combination. After this it sums it with the prior entry to have an accumulated sum. The process is repeated to calculate the sum of all counted comparisons.

* In this problem the biggest obstacle was to count the arithmetic continuously and efficiently. It was deduced that dynamic programing would be the route because it displayed the biggest key that static programming is required. The goal is to attain the sum with very few iterations using a structure to hold sums and at the end return the sum of the derived elements in the dp array. In order to attain this an array was used count the slices. Once the next iteration would begin it would count the current count plus the past sum. The anticipated result was achieved after several trials and the result was the sum of the array not the last entry. This problem like the rest exhibited a very similar pattern. The hardest part of these problems is identifying the pattern and thinking of a way to store the results in a form that are useable for future calculations. Using Dukes steps, I was able to break down the problems and think of the problem abstractly. In doing so it was possible to divide the problem into sub problem until is gave me the result I expected.
